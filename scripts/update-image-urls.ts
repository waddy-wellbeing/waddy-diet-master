#!/usr/bin/env tsx
/**
 * Update Image URLs Script
 * 
 * Updates recipes.image_url in the database to point to Supabase Storage URLs.
 * Uses the image-mapping.json generated by optimize-images.ts to match recipes to images.
 * 
 * Usage:
 *   npm run images:update-urls
 *   npm run images:update-urls -- --dry-run    # Preview without updating
 * 
 * Environment variables required:
 *   NEXT_PUBLIC_SUPABASE_URL
 *   SUPABASE_SERVICE_ROLE_KEY
 */

import * as dotenv from 'dotenv'
import * as fs from 'fs'
import * as path from 'path'
import { createSeedClient, log, createLookupVariants } from './utils'

// Load environment variables
dotenv.config({ path: '.env.local' })

// =============================================================================
// Configuration
// =============================================================================

const BUCKET_NAME = 'recipe-images'
const OPTIMIZED_DIR = path.join(process.cwd(), 'docs', 'datasets', 'images-optimized')
const MAPPING_FILE = path.join(OPTIMIZED_DIR, 'image-mapping.json')

// =============================================================================
// Helpers
// =============================================================================

interface UpdateResult {
  updated: number
  noImage: number
  failed: number
  errors: string[]
}

function buildImageLookupFromMapping(): Map<string, string> {
  const lookup = new Map<string, string>()

  if (!fs.existsSync(MAPPING_FILE)) {
    log.error(`Mapping file not found: ${MAPPING_FILE}`)
    log.info(`Run 'npm run images:optimize' first to generate the mapping.`)
    return lookup
  }

  const mapping: Record<string, string> = JSON.parse(fs.readFileSync(MAPPING_FILE, 'utf-8'))

  for (const [originalName, filename] of Object.entries(mapping)) {
    // Create lookup variants for the original name (supports Arabic matching)
    for (const key of createLookupVariants(originalName)) {
      if (!lookup.has(key)) {
        lookup.set(key, filename)
      }
    }
  }

  return lookup
}

// =============================================================================
// Main
// =============================================================================

async function main() {
  const args = process.argv.slice(2)
  const isDryRun = args.includes('--dry-run')

  log.header(`Update Recipe Image URLs ${isDryRun ? '(DRY RUN)' : ''}`)

  // Validate environment
  if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
    log.error('NEXT_PUBLIC_SUPABASE_URL is not set')
    process.exit(1)
  }

  if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {
    log.error('SUPABASE_SERVICE_ROLE_KEY is not set')
    process.exit(1)
  }

  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
  const baseImageUrl = `${supabaseUrl}/storage/v1/object/public/${BUCKET_NAME}`

  // Create Supabase client
  const supabase = createSeedClient()
  log.success('Connected to Supabase')

  // Build image lookup from mapping file
  const imageLookup = buildImageLookupFromMapping()
  
  if (imageLookup.size === 0) {
    process.exit(1)
  }
  
  log.info(`Found ${imageLookup.size} images in mapping lookup`)

  // Fetch all recipes
  const { data: recipes, error: fetchError } = await supabase
    .from('recipes')
    .select('id, name, image_url')

  if (fetchError) {
    log.error(`Failed to fetch recipes: ${fetchError.message}`)
    process.exit(1)
  }

  log.info(`Found ${recipes?.length || 0} recipes in database`)

  // Process recipes
  const result: UpdateResult = {
    updated: 0,
    noImage: 0,
    failed: 0,
    errors: [],
  }

  const updates: Array<{ id: string; name: string; oldUrl: string | null; newUrl: string }> = []

  for (const recipe of recipes || []) {
    // Try to find matching optimized image
    let matchedFile: string | undefined

    for (const key of createLookupVariants(recipe.name)) {
      const match = imageLookup.get(key)
      if (match) {
        matchedFile = match
        break
      }
    }

    if (!matchedFile) {
      result.noImage++
      continue
    }

    const newUrl = `${baseImageUrl}/cover/${matchedFile}`
    
    // Skip if already using the correct URL
    if (recipe.image_url === newUrl) {
      continue
    }

    updates.push({
      id: recipe.id,
      name: recipe.name,
      oldUrl: recipe.image_url,
      newUrl,
    })
  }

  log.info(`${updates.length} recipes need URL updates`)
  log.info(`${result.noImage} recipes have no matching image`)

  if (updates.length === 0) {
    log.success('No updates needed!')
    return
  }

  // Preview updates
  if (isDryRun) {
    log.subheader('Preview (first 10)')
    updates.slice(0, 10).forEach(u => {
      console.log(`  ${u.name}`)
      console.log(`    Old: ${u.oldUrl || '(none)'}`)
      console.log(`    New: ${u.newUrl}`)
    })
    if (updates.length > 10) {
      console.log(`  ... and ${updates.length - 10} more`)
    }
  }

  // Apply updates
  if (!isDryRun) {
    log.subheader('Updating database')

    for (let i = 0; i < updates.length; i++) {
      const update = updates[i]
      
      const { error } = await supabase
        .from('recipes')
        .update({ image_url: update.newUrl })
        .eq('id', update.id)

      if (error) {
        result.failed++
        result.errors.push(`${update.name}: ${error.message}`)
      } else {
        result.updated++
      }

      process.stdout.write(`\r  Progress: ${i + 1}/${updates.length}`)
    }

    console.log() // New line
  }

  // Summary
  log.header('Update Summary')
  
  if (isDryRun) {
    console.log(`  Would update: ${updates.length} recipes`)
    console.log(`  No image found: ${result.noImage} recipes`)
  } else {
    console.log(`  ✅ Updated: ${result.updated}`)
    console.log(`  ❌ Failed: ${result.failed}`)
    console.log(`  ⏭️  No image: ${result.noImage}`)
  }

  if (result.errors.length > 0) {
    console.log('\n  Errors:')
    result.errors.slice(0, 10).forEach(err => {
      console.log(`    - ${err}`)
    })
  }

  console.log(`\n  Image URL format: ${baseImageUrl}/cover/<filename>.webp`)

  if (isDryRun) {
    log.warning('Dry run complete. No changes were made.')
  } else {
    log.success('URL update complete!')
  }
}

main().catch(err => {
  log.error(`Fatal error: ${err}`)
  process.exit(1)
})
